{"ast":null,"code":"'use client';\n\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport { Delaunay } from '@mui/x-charts-vendor/d3-delaunay';\nimport useEnhancedEffect from '@mui/utils/useEnhancedEffect';\nimport { InteractionContext } from \"../context/InteractionProvider.js\";\nimport { useCartesianContext } from \"../context/CartesianProvider/index.js\";\nimport { getValueToPositionMapper } from \"../hooks/useScale.js\";\nimport { getSVGPoint } from \"../internals/getSVGPoint.js\";\nimport { useDrawingArea, useSvgRef } from \"../hooks/index.js\";\nimport { useHighlighted } from \"../context/index.js\";\nimport { useScatterSeries } from \"../hooks/useSeries.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nfunction ChartsVoronoiHandler(props) {\n  var _useScatterSeries;\n  const {\n    voronoiMaxRadius,\n    onItemClick\n  } = props;\n  const svgRef = useSvgRef();\n  const drawingArea = useDrawingArea();\n  const {\n    xAxis,\n    yAxis,\n    xAxisIds,\n    yAxisIds\n  } = useCartesianContext();\n  const {\n    dispatch\n  } = React.useContext(InteractionContext);\n  const {\n    series,\n    seriesOrder\n  } = (_useScatterSeries = useScatterSeries()) !== null && _useScatterSeries !== void 0 ? _useScatterSeries : {};\n  const voronoiRef = React.useRef({});\n  const delauneyRef = React.useRef(undefined);\n  const lastFind = React.useRef(undefined);\n  const {\n    setHighlighted,\n    clearHighlighted\n  } = useHighlighted();\n  const defaultXAxisId = xAxisIds[0];\n  const defaultYAxisId = yAxisIds[0];\n  useEnhancedEffect(() => {\n    dispatch({\n      type: 'updateVoronoiUsage',\n      useVoronoiInteraction: true\n    });\n    return () => {\n      dispatch({\n        type: 'updateVoronoiUsage',\n        useVoronoiInteraction: false\n      });\n    };\n  }, [dispatch]);\n  useEnhancedEffect(() => {\n    // This effect generate and store the Delaunay object that's used to map coordinate to closest point.\n\n    if (seriesOrder === undefined || series === undefined) {\n      // If there is no scatter chart series\n      return;\n    }\n    voronoiRef.current = {};\n    let points = [];\n    seriesOrder.forEach(seriesId => {\n      var _ref, _ref2;\n      const {\n        data,\n        xAxisId,\n        yAxisId,\n        xAxisKey,\n        yAxisKey\n      } = series[seriesId];\n      const xScale = xAxis[(_ref = xAxisId !== null && xAxisId !== void 0 ? xAxisId : xAxisKey) !== null && _ref !== void 0 ? _ref : defaultXAxisId].scale;\n      const yScale = yAxis[(_ref2 = yAxisId !== null && yAxisId !== void 0 ? yAxisId : yAxisKey) !== null && _ref2 !== void 0 ? _ref2 : defaultYAxisId].scale;\n      const getXPosition = getValueToPositionMapper(xScale);\n      const getYPosition = getValueToPositionMapper(yScale);\n      const seriesPoints = data.flatMap(_ref3 => {\n        let {\n          x,\n          y\n        } = _ref3;\n        const pointX = getXPosition(x);\n        const pointY = getYPosition(y);\n        if (!drawingArea.isPointInside({\n          x: pointX,\n          y: pointY\n        })) {\n          // If the point is not displayed we move them to a trash coordinate.\n          // This avoids managing index mapping before/after filtering.\n          // The trash point is far enough such that any point in the drawing area will be closer to the mouse than the trash coordinate.\n          return [-drawingArea.width, -drawingArea.height];\n        }\n        return [pointX, pointY];\n      });\n      voronoiRef.current[seriesId] = {\n        seriesId,\n        startIndex: points.length,\n        endIndex: points.length + seriesPoints.length\n      };\n      points = points.concat(seriesPoints);\n    });\n    delauneyRef.current = new Delaunay(points);\n    lastFind.current = undefined;\n  }, [defaultXAxisId, defaultYAxisId, series, seriesOrder, xAxis, yAxis, drawingArea]);\n  React.useEffect(() => {\n    if (svgRef.current === null) {\n      return undefined;\n    }\n    const element = svgRef.current;\n    function getClosestPoint(event) {\n      // Get mouse coordinate in global SVG space\n      const svgPoint = getSVGPoint(element, event);\n      if (!drawingArea.isPointInside(svgPoint)) {\n        lastFind.current = undefined;\n        return 'outside-chart';\n      }\n      if (!delauneyRef.current) {\n        return 'no-point-found';\n      }\n      const closestPointIndex = delauneyRef.current.find(svgPoint.x, svgPoint.y, lastFind.current);\n      if (closestPointIndex === undefined) {\n        return 'no-point-found';\n      }\n      lastFind.current = closestPointIndex;\n      const closestSeries = Object.values(voronoiRef.current).find(value => {\n        return 2 * closestPointIndex >= value.startIndex && 2 * closestPointIndex < value.endIndex;\n      });\n      if (closestSeries === undefined) {\n        return 'no-point-found';\n      }\n      const dataIndex = (2 * closestPointIndex - voronoiRef.current[closestSeries.seriesId].startIndex) / 2;\n      if (voronoiMaxRadius !== undefined) {\n        const pointX = delauneyRef.current.points[2 * closestPointIndex];\n        const pointY = delauneyRef.current.points[2 * closestPointIndex + 1];\n        const dist2 = (pointX - svgPoint.x) ** 2 + (pointY - svgPoint.y) ** 2;\n        if (dist2 > voronoiMaxRadius ** 2) {\n          // The closest point is too far to be considered.\n          return 'outside-voronoi-max-radius';\n        }\n      }\n      return {\n        seriesId: closestSeries.seriesId,\n        dataIndex\n      };\n    }\n    const handleMouseLeave = () => {\n      dispatch({\n        type: 'exitChart'\n      });\n      clearHighlighted();\n    };\n    const handleMouseMove = event => {\n      const closestPoint = getClosestPoint(event);\n      if (closestPoint === 'outside-chart') {\n        dispatch({\n          type: 'exitChart'\n        });\n        clearHighlighted();\n        return;\n      }\n      if (closestPoint === 'outside-voronoi-max-radius' || closestPoint === 'no-point-found') {\n        dispatch({\n          type: 'leaveItem',\n          data: {\n            type: 'scatter'\n          }\n        });\n        clearHighlighted();\n        return;\n      }\n      const {\n        seriesId,\n        dataIndex\n      } = closestPoint;\n      dispatch({\n        type: 'enterItem',\n        data: {\n          type: 'scatter',\n          seriesId,\n          dataIndex\n        }\n      });\n      setHighlighted({\n        seriesId,\n        dataIndex\n      });\n    };\n    const handleMouseClick = event => {\n      if (!onItemClick) {\n        return;\n      }\n      const closestPoint = getClosestPoint(event);\n      if (typeof closestPoint === 'string') {\n        // No point fond for any reason\n        return;\n      }\n      const {\n        seriesId,\n        dataIndex\n      } = closestPoint;\n      onItemClick(event, {\n        type: 'scatter',\n        seriesId,\n        dataIndex\n      });\n    };\n    element.addEventListener('pointerleave', handleMouseLeave);\n    element.addEventListener('pointermove', handleMouseMove);\n    element.addEventListener('click', handleMouseClick);\n    return () => {\n      element.removeEventListener('pointerleave', handleMouseLeave);\n      element.removeEventListener('pointermove', handleMouseMove);\n      element.removeEventListener('click', handleMouseClick);\n    };\n  }, [svgRef, dispatch, yAxis, xAxis, voronoiMaxRadius, onItemClick, setHighlighted, clearHighlighted, drawingArea]);\n\n  // eslint-disable-next-line react/jsx-no-useless-fragment\n  return /*#__PURE__*/_jsx(React.Fragment, {});\n}\nprocess.env.NODE_ENV !== \"production\" ? ChartsVoronoiHandler.propTypes = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // | To update them edit the TypeScript types and run \"pnpm proptypes\"  |\n  // ----------------------------------------------------------------------\n  /**\n   * Callback fired when clicking on a scatter item.\n   * @param {MouseEvent} event Mouse event caught at the svg level\n   * @param {ScatterItemIdentifier} scatterItemIdentifier Identify which item got clicked\n   */\n  onItemClick: PropTypes.func,\n  /**\n   * Defines the maximal distance between a scatter point and the pointer that triggers the interaction.\n   * If `undefined`, the radius is assumed to be infinite.\n   */\n  voronoiMaxRadius: PropTypes.number\n} : void 0;\nexport { ChartsVoronoiHandler };","map":{"version":3,"names":["React","PropTypes","Delaunay","useEnhancedEffect","InteractionContext","useCartesianContext","getValueToPositionMapper","getSVGPoint","useDrawingArea","useSvgRef","useHighlighted","useScatterSeries","jsx","_jsx","ChartsVoronoiHandler","props","_useScatterSeries","voronoiMaxRadius","onItemClick","svgRef","drawingArea","xAxis","yAxis","xAxisIds","yAxisIds","dispatch","useContext","series","seriesOrder","voronoiRef","useRef","delauneyRef","undefined","lastFind","setHighlighted","clearHighlighted","defaultXAxisId","defaultYAxisId","type","useVoronoiInteraction","current","points","forEach","seriesId","_ref","_ref2","data","xAxisId","yAxisId","xAxisKey","yAxisKey","xScale","scale","yScale","getXPosition","getYPosition","seriesPoints","flatMap","_ref3","x","y","pointX","pointY","isPointInside","width","height","startIndex","length","endIndex","concat","useEffect","element","getClosestPoint","event","svgPoint","closestPointIndex","find","closestSeries","Object","values","value","dataIndex","dist2","handleMouseLeave","handleMouseMove","closestPoint","handleMouseClick","addEventListener","removeEventListener","Fragment","process","env","NODE_ENV","propTypes","func","number"],"sources":["/Users/felipemalfitani/Documents/GitHub/elevat-ed/node_modules/@mui/x-charts/ChartsVoronoiHandler/ChartsVoronoiHandler.js"],"sourcesContent":["'use client';\n\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport { Delaunay } from '@mui/x-charts-vendor/d3-delaunay';\nimport useEnhancedEffect from '@mui/utils/useEnhancedEffect';\nimport { InteractionContext } from \"../context/InteractionProvider.js\";\nimport { useCartesianContext } from \"../context/CartesianProvider/index.js\";\nimport { getValueToPositionMapper } from \"../hooks/useScale.js\";\nimport { getSVGPoint } from \"../internals/getSVGPoint.js\";\nimport { useDrawingArea, useSvgRef } from \"../hooks/index.js\";\nimport { useHighlighted } from \"../context/index.js\";\nimport { useScatterSeries } from \"../hooks/useSeries.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nfunction ChartsVoronoiHandler(props) {\n  const {\n    voronoiMaxRadius,\n    onItemClick\n  } = props;\n  const svgRef = useSvgRef();\n  const drawingArea = useDrawingArea();\n  const {\n    xAxis,\n    yAxis,\n    xAxisIds,\n    yAxisIds\n  } = useCartesianContext();\n  const {\n    dispatch\n  } = React.useContext(InteractionContext);\n  const {\n    series,\n    seriesOrder\n  } = useScatterSeries() ?? {};\n  const voronoiRef = React.useRef({});\n  const delauneyRef = React.useRef(undefined);\n  const lastFind = React.useRef(undefined);\n  const {\n    setHighlighted,\n    clearHighlighted\n  } = useHighlighted();\n  const defaultXAxisId = xAxisIds[0];\n  const defaultYAxisId = yAxisIds[0];\n  useEnhancedEffect(() => {\n    dispatch({\n      type: 'updateVoronoiUsage',\n      useVoronoiInteraction: true\n    });\n    return () => {\n      dispatch({\n        type: 'updateVoronoiUsage',\n        useVoronoiInteraction: false\n      });\n    };\n  }, [dispatch]);\n  useEnhancedEffect(() => {\n    // This effect generate and store the Delaunay object that's used to map coordinate to closest point.\n\n    if (seriesOrder === undefined || series === undefined) {\n      // If there is no scatter chart series\n      return;\n    }\n    voronoiRef.current = {};\n    let points = [];\n    seriesOrder.forEach(seriesId => {\n      const {\n        data,\n        xAxisId,\n        yAxisId,\n        xAxisKey,\n        yAxisKey\n      } = series[seriesId];\n      const xScale = xAxis[xAxisId ?? xAxisKey ?? defaultXAxisId].scale;\n      const yScale = yAxis[yAxisId ?? yAxisKey ?? defaultYAxisId].scale;\n      const getXPosition = getValueToPositionMapper(xScale);\n      const getYPosition = getValueToPositionMapper(yScale);\n      const seriesPoints = data.flatMap(({\n        x,\n        y\n      }) => {\n        const pointX = getXPosition(x);\n        const pointY = getYPosition(y);\n        if (!drawingArea.isPointInside({\n          x: pointX,\n          y: pointY\n        })) {\n          // If the point is not displayed we move them to a trash coordinate.\n          // This avoids managing index mapping before/after filtering.\n          // The trash point is far enough such that any point in the drawing area will be closer to the mouse than the trash coordinate.\n          return [-drawingArea.width, -drawingArea.height];\n        }\n        return [pointX, pointY];\n      });\n      voronoiRef.current[seriesId] = {\n        seriesId,\n        startIndex: points.length,\n        endIndex: points.length + seriesPoints.length\n      };\n      points = points.concat(seriesPoints);\n    });\n    delauneyRef.current = new Delaunay(points);\n    lastFind.current = undefined;\n  }, [defaultXAxisId, defaultYAxisId, series, seriesOrder, xAxis, yAxis, drawingArea]);\n  React.useEffect(() => {\n    if (svgRef.current === null) {\n      return undefined;\n    }\n    const element = svgRef.current;\n    function getClosestPoint(event) {\n      // Get mouse coordinate in global SVG space\n      const svgPoint = getSVGPoint(element, event);\n      if (!drawingArea.isPointInside(svgPoint)) {\n        lastFind.current = undefined;\n        return 'outside-chart';\n      }\n      if (!delauneyRef.current) {\n        return 'no-point-found';\n      }\n      const closestPointIndex = delauneyRef.current.find(svgPoint.x, svgPoint.y, lastFind.current);\n      if (closestPointIndex === undefined) {\n        return 'no-point-found';\n      }\n      lastFind.current = closestPointIndex;\n      const closestSeries = Object.values(voronoiRef.current).find(value => {\n        return 2 * closestPointIndex >= value.startIndex && 2 * closestPointIndex < value.endIndex;\n      });\n      if (closestSeries === undefined) {\n        return 'no-point-found';\n      }\n      const dataIndex = (2 * closestPointIndex - voronoiRef.current[closestSeries.seriesId].startIndex) / 2;\n      if (voronoiMaxRadius !== undefined) {\n        const pointX = delauneyRef.current.points[2 * closestPointIndex];\n        const pointY = delauneyRef.current.points[2 * closestPointIndex + 1];\n        const dist2 = (pointX - svgPoint.x) ** 2 + (pointY - svgPoint.y) ** 2;\n        if (dist2 > voronoiMaxRadius ** 2) {\n          // The closest point is too far to be considered.\n          return 'outside-voronoi-max-radius';\n        }\n      }\n      return {\n        seriesId: closestSeries.seriesId,\n        dataIndex\n      };\n    }\n    const handleMouseLeave = () => {\n      dispatch({\n        type: 'exitChart'\n      });\n      clearHighlighted();\n    };\n    const handleMouseMove = event => {\n      const closestPoint = getClosestPoint(event);\n      if (closestPoint === 'outside-chart') {\n        dispatch({\n          type: 'exitChart'\n        });\n        clearHighlighted();\n        return;\n      }\n      if (closestPoint === 'outside-voronoi-max-radius' || closestPoint === 'no-point-found') {\n        dispatch({\n          type: 'leaveItem',\n          data: {\n            type: 'scatter'\n          }\n        });\n        clearHighlighted();\n        return;\n      }\n      const {\n        seriesId,\n        dataIndex\n      } = closestPoint;\n      dispatch({\n        type: 'enterItem',\n        data: {\n          type: 'scatter',\n          seriesId,\n          dataIndex\n        }\n      });\n      setHighlighted({\n        seriesId,\n        dataIndex\n      });\n    };\n    const handleMouseClick = event => {\n      if (!onItemClick) {\n        return;\n      }\n      const closestPoint = getClosestPoint(event);\n      if (typeof closestPoint === 'string') {\n        // No point fond for any reason\n        return;\n      }\n      const {\n        seriesId,\n        dataIndex\n      } = closestPoint;\n      onItemClick(event, {\n        type: 'scatter',\n        seriesId,\n        dataIndex\n      });\n    };\n    element.addEventListener('pointerleave', handleMouseLeave);\n    element.addEventListener('pointermove', handleMouseMove);\n    element.addEventListener('click', handleMouseClick);\n    return () => {\n      element.removeEventListener('pointerleave', handleMouseLeave);\n      element.removeEventListener('pointermove', handleMouseMove);\n      element.removeEventListener('click', handleMouseClick);\n    };\n  }, [svgRef, dispatch, yAxis, xAxis, voronoiMaxRadius, onItemClick, setHighlighted, clearHighlighted, drawingArea]);\n\n  // eslint-disable-next-line react/jsx-no-useless-fragment\n  return /*#__PURE__*/_jsx(React.Fragment, {});\n}\nprocess.env.NODE_ENV !== \"production\" ? ChartsVoronoiHandler.propTypes = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // | To update them edit the TypeScript types and run \"pnpm proptypes\"  |\n  // ----------------------------------------------------------------------\n  /**\n   * Callback fired when clicking on a scatter item.\n   * @param {MouseEvent} event Mouse event caught at the svg level\n   * @param {ScatterItemIdentifier} scatterItemIdentifier Identify which item got clicked\n   */\n  onItemClick: PropTypes.func,\n  /**\n   * Defines the maximal distance between a scatter point and the pointer that triggers the interaction.\n   * If `undefined`, the radius is assumed to be infinite.\n   */\n  voronoiMaxRadius: PropTypes.number\n} : void 0;\nexport { ChartsVoronoiHandler };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}